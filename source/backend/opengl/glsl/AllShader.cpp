#include "../AllShader.h"
const char* glsl_convlutionDepthwise_glsl = 
"layout(std430) buffer;\n"
"layout(FORMAT, binding=0) writeonly uniform mediump image3D uOutput;\n"
"layout(location=1) uniform mediump sampler3D uInput;\n"
"layout(location=2) uniform mediump sampler3D uKernel;\n"
"layout(binding=3) readonly buffer bias{\n"
"    vec4 data[];\n"
"} uBias;\n"
"layout(location=4) uniform ivec2 uPad;\n"
"layout(location=5) uniform ivec2 uKernelSize;\n"
"layout(location=6) uniform ivec2 uStride;\n"
"layout(location=7) uniform ivec2 uDilate;\n"
"// layout(location=8) uniform ivec2 uOffset;\n"
"// layout(location=9) uniform float uReluRate;\n"
"layout(location=10) uniform ivec3 uOutputSize;\n"
"layout(location=11) uniform ivec3 uInputSize;\n"
"#define UP_DIV(x, y) (((x)+(y)-1)/(y))\n"
"layout (local_size_x = XLOCAL, local_size_y = YLOCAL, local_size_z = ZLOCAL) in;\n"
"void main()\n"
"{\n"
"    ivec3 pos = ivec3(gl_GlobalInvocationID)*ivec3(1, 1, 1);\n"
"    ivec3 outputSize = uOutputSize;\n"
"    if (all(lessThan(pos, outputSize)))\n"
"    {\n"
"        int KSIZE_Y = uKernelSize.y;\n"
"        int KSIZE_X = uKernelSize.x;\n"
"        ivec3 inputSize = uInputSize;\n"
"        ivec2 s0 = pos.xy*uStride-uPad;\n"
"        int fx, fy, fz;\n"
"        ivec2 sfxy = max(ivec2(0), (UP_DIV(-s0, uDilate)));\n"
"        ivec2 efxy = min(uKernelSize, UP_DIV(inputSize.xy-s0, uDilate));\n"
"        vec4 color = uBias.data[pos.z];\n"
"        for (fy=sfxy.y; fy<efxy.y; ++fy)\n"
"        {\n"
"            int sy = fy*uDilate.y + s0.y;\n"
"            for (fx=sfxy.x; fx<efxy.x; ++fx)\n"
"            {\n"
"                int sx1 = fx*uDilate.x + s0.x;\n"
"                vec4 k = texelFetch(uKernel, ivec3(pos.z, fx, fy), 0);\n"
"                color  += k*texelFetch(uInput, ivec3(sx1, sy, pos.z), 0);\n"
"            }\n"
"        }\n"
"#ifdef RELU\n"
"        color = max(color, vec4(0));\n"
"#endif\n"
"#ifdef RELU6\n"
"        color = clamp(color, vec4(0), vec4(6));\n"
"#endif\n"
"        imageStore(uOutput, pos, color);\n"
"    }\n"
"}\n"
;
const char* glsl_upload_glsl = 
"layout(FORMAT, binding=0) writeonly uniform PRECISION image3D uImage;\n"
"layout(binding=1) readonly buffer destBuffer{\n"
"    float data[];\n"
"} uInBuffer;\n"
"layout(location = 2) uniform int uWidth;\n"
"layout(location = 3) uniform int uHeight;\n"
"layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;\n"
"void main()\n"
"{\n"
"    ivec3 pos = ivec3(gl_GlobalInvocationID);\n"
"    if (pos.x < uWidth && pos.y < uHeight)\n"
"    {\n"
"        vec4 color;\n"
"        int z = pos.z*4;\n"
"        color.r = uInBuffer.data[uWidth*pos.y+pos.x+(z+0)*uWidth*uHeight];\n"
"        color.g = uInBuffer.data[uWidth*pos.y+pos.x+(z+1)*uWidth*uHeight];\n"
"        color.b = uInBuffer.data[uWidth*pos.y+pos.x+(z+2)*uWidth*uHeight];\n"
"        color.a = uInBuffer.data[uWidth*pos.y+pos.x+(z+3)*uWidth*uHeight];\n"
"        imageStore(uImage, pos, color);\n"
"    }\n"
"}\n"
;
const char* glsl_eltwise_glsl = 
"layout(FORMAT, binding=1) writeonly uniform PRECISION image3D uOutput;\n"
"layout(location=10) uniform ivec3 uOutputSize;\n"
"layout (local_size_x = 2, local_size_y = 2, local_size_z = 16) in;\n"
"void main()\n"
"{\n"
"    ivec3 pos = ivec3(gl_GlobalInvocationID);\n"
"    ivec3 outputSize = uOutputSize;\n"
"    if (all(lessThan(pos, outputSize)))\n"
"    {\n"
"        vec4 color = MAINOP(pos);\n"
"        imageStore(uOutput, pos, color);\n"
"    }\n"
"}\n"
;
const char* glsl_kernel2image_glsl = 
"layout(std430) buffer;\n"
"layout(FORMAT, binding=0) writeonly uniform PRECISION image3D uOutput;\n"
"layout(binding=2) readonly buffer kernel{\n"
"    vec4 data[];\n"
"} uKernel;\n"
"layout(location = 3) uniform int uFxFy;\n"
"layout(location = 4) uniform int uSrcCount;\n"
"layout (local_size_x = 1, local_size_y = 1, local_size_z = 1) in;\n"
"void main()\n"
"{\n"
"    ivec3 pos = ivec3(gl_GlobalInvocationID) * ivec3(4, 1, 1);\n"
"    int kernelPos = 0\n"
"        + pos.x * uFxFy\n"
"        + 4*pos.y * uSrcCount * uFxFy\n"
"        + 4*pos.z\n"
"        ;\n"
"    vec4 color0 = uKernel.data[kernelPos+0];\n"
"    vec4 color1 = uKernel.data[kernelPos+1];\n"
"    vec4 color2 = uKernel.data[kernelPos+2];\n"
"    vec4 color3 = uKernel.data[kernelPos+3];\n"
"    imageStore(uOutput, ivec3(pos.x+0, pos.y, pos.z), color0);\n"
"    imageStore(uOutput, ivec3(pos.x+1, pos.y, pos.z), color1);\n"
"    imageStore(uOutput, ivec3(pos.x+2, pos.y, pos.z), color2);\n"
"    imageStore(uOutput, ivec3(pos.x+3, pos.y, pos.z), color3);\n"
"}\n"
;
const char* glsl_convolution1x1_glsl = 
"layout(std430) buffer;\n"
"layout(FORMAT, binding=0) writeonly uniform PRECISION image3D uOutput;\n"
"layout(location=1) uniform mediump sampler3D uInput;\n"
"layout(location=2) uniform mediump sampler3D uKernel;\n"
"layout(binding=3) readonly buffer bias{\n"
"    vec4 data[];\n"
"} uBias;\n"
"layout(location=8) uniform int uUnroll;\n"
"layout(location=10) uniform ivec3 uOutputSize;\n"
"layout(location=11) uniform ivec3 uInputSize;\n"
"#define UP_DIV(x, y) (((x)+(y)-1)/(y))\n"
"layout (local_size_x = XLOCAL, local_size_y = YLOCAL, local_size_z = ZLOCAL) in;\n"
"void main()\n"
"{\n"
"    ivec3 pos = ivec3(gl_GlobalInvocationID)*ivec3(uUnroll, 1, 1);\n"
"    ivec3 outputSize = uOutputSize;\n"
"    if (all(lessThan(pos, outputSize)))\n"
"    {\n"
"        ivec3 inputSize = uInputSize;\n"
"        int sy = pos.y;\n"
"        int sx = pos.x;\n"
"        int fx, fy, fz;\n"
"        vec4 color = uBias.data[pos.z];\n"
"        vec4 color2 = color;\n"
"        vec4 color3 = color;\n"
"        vec4 color4 = color;\n"
"        int kernelY = pos.z;\n"
"        for (fz=0; fz<inputSize.z; ++fz)\n"
"        {\n"
"            int kernelX = 4*fz;\n"
"            vec4 k0 = texelFetch(uKernel, ivec3(kernelX+0, kernelY, 0), 0);\n"
"            vec4 k1 = texelFetch(uKernel, ivec3(kernelX+1, kernelY, 0), 0);\n"
"            vec4 k2 = texelFetch(uKernel, ivec3(kernelX+2, kernelY, 0), 0);\n"
"            vec4 k3 = texelFetch(uKernel, ivec3(kernelX+3, kernelY, 0), 0);\n"
"            mat4 k = mat4(k0, k1, k2, k3);\n"
"            color  += k*texelFetch(uInput, ivec3(sx+0, sy, fz), 0);\n"
"            color2 += k*texelFetch(uInput, ivec3(sx+1, sy, fz), 0);\n"
"            color3 += k*texelFetch(uInput, ivec3(sx+2, sy, fz), 0);\n"
"            color4 += k*texelFetch(uInput, ivec3(sx+3, sy, fz), 0);\n"
"        }\n"
"#ifdef RELU\n"
"        color = max(color, vec4(0));\n"
"        color2 = max(color2, vec4(0));\n"
"        color3 = max(color3, vec4(0));\n"
"        color4 = max(color4, vec4(0));\n"
"#endif\n"
"#ifdef RELU6\n"
"        color = clamp(color, vec4(0), vec4(6));\n"
"        color2 = clamp(color2, vec4(0), vec4(6));\n"
"        color3 = clamp(color3, vec4(0), vec4(6));\n"
"        color4 = clamp(color4, vec4(0), vec4(6));\n"
"#endif\n"
"        imageStore(uOutput, ivec3(pos.x+0, pos.y, pos.z), color);\n"
"        imageStore(uOutput, ivec3(pos.x+1, pos.y, pos.z), color2);\n"
"        imageStore(uOutput, ivec3(pos.x+2, pos.y, pos.z), color3);\n"
"        imageStore(uOutput, ivec3(pos.x+3, pos.y, pos.z), color4);\n"
"    }\n"
"}\n"
;
const char* glsl_image2Buffer_glsl = 
"layout(FORMAT, binding=0) readonly uniform PRECISION image3D uImage;\n"
"layout(std430, binding=1) writeonly buffer destBuffer{\n"
"    vec4 data[];\n"
"} uOutBuffer;\n"
"layout(location = 2) uniform int uWidth;\n"
"layout(location = 3) uniform int uHeight;\n"
"layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;\n"
"void main()\n"
"{\n"
"    ivec3 pos = ivec3(gl_GlobalInvocationID);\n"
"    if (pos.x < uWidth && pos.y < uHeight)\n"
"    {\n"
"        vec4 color = imageLoad(uImage, pos);\n"
"        uOutBuffer.data[uWidth*pos.y+pos.x+pos.z*uWidth*uHeight] = color;\n"
"    }\n"
"}\n"
;
const char* glsl_avgpool_glsl = 
"layout(FORMAT, binding=0, location=0) readonly uniform PRECISION image3D uInput;\n"
"layout(FORMAT, binding=1, location=1) writeonly uniform PRECISION image3D uOutput;\n"
"layout(location = 2) uniform ivec2 uKernel;\n"
"layout(location = 3) uniform ivec2 uStride;\n"
"layout(location = 4) uniform ivec2 uPad;\n"
"layout(location=10) uniform ivec3 uOutputSize;\n"
"layout(location=11) uniform ivec3 uInputSize;\n"
"layout (local_size_x = 2, local_size_y = 2, local_size_z = 16) in;\n"
"void main()\n"
"{\n"
"    ivec3 pos = ivec3(gl_GlobalInvocationID);\n"
"    ivec3 outputSize = uOutputSize;\n"
"    ivec2 spos = pos.xy*uStride-uPad;\n"
"    if (all(lessThan(pos, outputSize)))\n"
"    {\n"
"        ivec2 inputSizeXY = uInputSize.xy;\n"
"        vec4 color = vec4(0.0);\n"
"        vec4 num = vec4(0.0);\n"
"        ivec2 sfxy = max(ivec2(0), -spos);\n"
"        ivec2 efxy = min(uKernel, inputSizeXY-spos);\n"
"        for (int fy=sfxy.y; fy<efxy.y; ++fy)\n"
"        {\n"
"            for (int fx=sfxy.x; fx<efxy.x; ++fx)\n"
"            {\n"
"                ivec2 spos_ = spos + ivec2(fx, fy);\n"
"                color += imageLoad(uInput, ivec3(spos.x+fx, spos.y+fy, pos.z));\n"
"                num += vec4(1.0);\n"
"            }\n"
"        }\n"
"        imageStore(uOutput, pos, color/num);\n"
"    }\n"
"}\n"
;
const char* glsl_maxpool_glsl = 
"layout(FORMAT, binding=0) readonly uniform PRECISION image3D uInput;\n"
"layout(FORMAT, binding=1) writeonly uniform PRECISION image3D uOutput;\n"
"layout(location = 2) uniform ivec2 uKernel;\n"
"layout(location = 3) uniform ivec2 uStride;\n"
"layout(location = 4) uniform ivec2 uPad;\n"
"layout(location=10) uniform ivec3 uOutputSize;\n"
"layout(location=11) uniform ivec3 uInputSize;\n"
"layout (local_size_x = 2, local_size_y = 2, local_size_z = 16) in;\n"
"void main()\n"
"{\n"
"    ivec3 pos = ivec3(gl_GlobalInvocationID);\n"
"    ivec3 outputSize = uOutputSize;\n"
"    ivec2 spos = pos.xy*uStride-uPad;\n"
"    if (all(lessThan(pos, outputSize)))\n"
"    {\n"
"        ivec3 inputSize = uInputSize;\n"
"        ivec2 sfxy = max(ivec2(0), -spos);\n"
"        ivec2 efxy = min(uKernel, inputSize.xy-spos);\n"
"        vec4 color = vec4(-100000.0);\n"
"        for (int fy=sfxy.y; fy<efxy.y; ++fy)\n"
"        {\n"
"            for (int fx=sfxy.x; fx<efxy.x; ++fx)\n"
"            {\n"
"                color = max(color, imageLoad(uInput, ivec3(spos.x+fx, spos.y+fy, pos.z)));\n"
"            }\n"
"        }\n"
"        imageStore(uOutput, pos, color);\n"
"    }\n"
"}\n"
;
const char* glsl_download_glsl = 
"layout(FORMAT, binding=0) readonly uniform PRECISION image3D uImage;\n"
"layout(binding=1) writeonly buffer destBuffer{\n"
"    float data[];\n"
"} uOutBuffer;\n"
"layout(location = 2) uniform int uWidth;\n"
"layout(location = 3) uniform int uHeight;\n"
"layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;\n"
"void main()\n"
"{\n"
"    ivec3 pos = ivec3(gl_GlobalInvocationID);\n"
"    if (pos.x < uWidth && pos.y < uHeight)\n"
"    {\n"
"        vec4 color = imageLoad(uImage, pos);\n"
"        int z = pos.z*4;\n"
"        uOutBuffer.data[uWidth*pos.y+pos.x+(z+0)*uWidth*uHeight] = color.r;\n"
"        uOutBuffer.data[uWidth*pos.y+pos.x+(z+1)*uWidth*uHeight] = color.g;\n"
"        uOutBuffer.data[uWidth*pos.y+pos.x+(z+2)*uWidth*uHeight] = color.b;\n"
"        uOutBuffer.data[uWidth*pos.y+pos.x+(z+3)*uWidth*uHeight] = color.a;\n"
"    }\n"
"}\n"
;
const char* glsl_blit_glsl = 
"layout(FORMAT, binding=0) writeonly uniform PRECISION image3D uOutput;\n"
"layout(FORMAT, binding=1) readonly uniform PRECISION image3D uInput;\n"
"layout(location = 2) uniform ivec3 uSourceOffset;\n"
"layout(location = 3) uniform ivec3 uDestOffset;\n"
"layout(location = 4) uniform ivec3 uBlitSize;\n"
"layout (local_size_x = 4, local_size_y = 4, local_size_z = 4) in;\n"
"void main()\n"
"{\n"
"    ivec3 pos = ivec3(gl_GlobalInvocationID);\n"
"    if (all(lessThan(pos, uBlitSize)))\n"
"    {\n"
"        ivec3 dstP = uDestOffset + pos;\n"
"        ivec3 srcP = uSourceOffset + pos;\n"
"        imageStore(uOutput, dstP, imageLoad(uInput, srcP));\n"
"    }\n"
"}\n"
;
const char* glsl_kernel2ImageDepthwise_glsl = 
"layout(std430) buffer;\n"
"layout(FORMAT, binding=0) writeonly uniform PRECISION image3D uOutput;\n"
"layout(binding=2) readonly buffer kernel{\n"
"    float data[];\n"
"} uKernel;\n"
"layout(location = 3) uniform int uFx;\n"
"layout(location = 4) uniform int uFy;\n"
"layout (local_size_x = 1, local_size_y = 1, local_size_z = 1) in;\n"
"void main()\n"
"{\n"
"    ivec3 pos = ivec3(gl_GlobalInvocationID);\n"
"    int fx = pos.y;\n"
"    int fy = pos.z;\n"
"    int z0 = pos.x * 4 + 0;\n"
"    int z1 = pos.x * 4 + 1;\n"
"    int z2 = pos.x * 4 + 2;\n"
"    int z3 = pos.x * 4 + 3;\n"
"    int p0 = z0*uFx*uFy + fy*uFx + fx;\n"
"    int p1 = z1*uFx*uFy + fy*uFx + fx;\n"
"    int p2 = z2*uFx*uFy + fy*uFx + fx;\n"
"    int p3 = z3*uFx*uFy + fy*uFx + fx;\n"
"    vec4 color = vec4(\n"
"        uKernel.data[p0],\n"
"        uKernel.data[p1],\n"
"        uKernel.data[p2],\n"
"        uKernel.data[p3]    \n"
"    );\n"
"    imageStore(uOutput, pos, color);\n"
"}\n"
;
const char* glsl_buffer2Image_glsl = 
"layout(FORMAT, binding=0) writeonly uniform PRECISION image3D uImage;\n"
"layout(binding=1) readonly buffer destBuffer{\n"
"    vec4 data[];\n"
"} uInBuffer;\n"
"layout(location = 2) uniform int uWidth;\n"
"layout(location = 3) uniform int uHeight;\n"
"layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;\n"
"void main()\n"
"{\n"
"    ivec3 pos = ivec3(gl_GlobalInvocationID);\n"
"    if (pos.x < uWidth && pos.y < uHeight)\n"
"    {\n"
"        vec4 color = uInBuffer.data[uWidth*pos.y+pos.x+pos.z*uWidth*uHeight];\n"
"        imageStore(uImage, pos, color);\n"
"    }\n"
"}\n"
;
const char* glsl_convolution_glsl = 
"layout(std430) buffer;\n"
"layout(FORMAT, binding=0) writeonly uniform PRECISION image3D uOutput;\n"
"layout(location=1) uniform mediump sampler3D uInput;\n"
"layout(location=2) uniform mediump sampler3D uKernel;\n"
"layout(binding=3) readonly buffer bias{\n"
"    vec4 data[];\n"
"} uBias;\n"
"layout(location=4) uniform ivec2 uPad;\n"
"layout(location=5) uniform ivec2 uKernelSize;\n"
"layout(location=6) uniform ivec2 uStride;\n"
"layout(location=7) uniform ivec2 uDilate;\n"
"layout(location=8) uniform int uUnroll;\n"
"layout(location=10) uniform ivec3 uOutputSize;\n"
"layout(location=11) uniform ivec3 uInputSize;\n"
"#define UP_DIV(x, y) (((x)+(y)-1)/(y))\n"
"layout (local_size_x = XLOCAL, local_size_y = YLOCAL, local_size_z = ZLOCAL) in;\n"
"void main()\n"
"{\n"
"    ivec3 pos = ivec3(gl_GlobalInvocationID)*ivec3(uUnroll, 1, 1);\n"
"    ivec3 outputSize = uOutputSize;\n"
"    if (all(lessThan(pos, outputSize)))\n"
"    {\n"
"        int KSIZE_Y = uKernelSize.y;\n"
"        int KSIZE_X = uKernelSize.x;\n"
"        ivec3 inputSize = uInputSize;\n"
"        ivec2 s0 = pos.xy*uStride-uPad;\n"
"        int fx, fy, fz;\n"
"        ivec2 sfxy = max(ivec2(0), (UP_DIV(-s0, uDilate)));\n"
"        ivec2 efxy = min(uKernelSize, UP_DIV(inputSize.xy-s0, uDilate));\n"
"        vec4 color = uBias.data[pos.z];\n"
"        vec4 color2 = color;\n"
"        vec4 color3 = color;\n"
"        vec4 color4 = color;\n"
"        int kernelY = pos.z;\n"
"        for (fy=sfxy.y; fy<efxy.y; ++fy)\n"
"        {\n"
"            int sy = fy*uDilate.y + s0.y;\n"
"            for (fx=0; fx<KSIZE_X; ++fx)\n"
"            {\n"
"                int kernelZ = fx + fy*KSIZE_X;\n"
"                int sx1 = fx*uDilate.x + s0.x;\n"
"                int sx2 = sx1 + uStride.x;\n"
"                int sx3 = sx1 + uStride.x * 2;\n"
"                int sx4 = sx1 + uStride.x * 3;\n"
"                float m1 = sx1 >= 0&& sx1 < inputSize.x ? 1.0 : 0.0;\n"
"                float m2 = sx2 >= 0&& sx2 < inputSize.x ? 1.0 : 0.0;\n"
"                float m3 = sx3 >= 0&& sx3 < inputSize.x ? 1.0 : 0.0;\n"
"                float m4 = sx4 >= 0&& sx4 < inputSize.x ? 1.0 : 0.0;\n"
"                fz = 0;\n"
"                for (; fz<inputSize.z; ++fz)\n"
"                {\n"
"                    int kernelX = 4*fz;\n"
"                    vec4 k0 = texelFetch(uKernel, ivec3(kernelX+0, kernelY, kernelZ), 0);\n"
"                    vec4 k1 = texelFetch(uKernel, ivec3(kernelX+1, kernelY, kernelZ), 0);\n"
"                    vec4 k2 = texelFetch(uKernel, ivec3(kernelX+2, kernelY, kernelZ), 0);\n"
"                    vec4 k3 = texelFetch(uKernel, ivec3(kernelX+3, kernelY, kernelZ), 0);\n"
"                    mat4 k = mat4(k0, k1, k2, k3);\n"
"                    color  += k*texelFetch(uInput, ivec3(sx1, sy, fz), 0) * m1;\n"
"                    color2 += k*texelFetch(uInput, ivec3(sx2, sy, fz), 0) * m2;\n"
"                    color3 += k*texelFetch(uInput, ivec3(sx3, sy, fz), 0) * m3;\n"
"                    color4 += k*texelFetch(uInput, ivec3(sx4, sy, fz), 0) * m4;\n"
"                }\n"
"            }\n"
"        }\n"
"#ifdef RELU\n"
"        color = max(color, vec4(0));\n"
"        color2 = max(color2, vec4(0));\n"
"        color3 = max(color3, vec4(0));\n"
"        color4 = max(color4, vec4(0));\n"
"#endif\n"
"#ifdef RELU6\n"
"        color = clamp(color, vec4(0), vec4(6));\n"
"        color2 = clamp(color2, vec4(0), vec4(6));\n"
"        color3 = clamp(color3, vec4(0), vec4(6));\n"
"        color4 = clamp(color4, vec4(0), vec4(6));\n"
"#endif\n"
"        imageStore(uOutput, ivec3(pos.x+0, pos.y, pos.z), color);\n"
"        imageStore(uOutput, ivec3(pos.x+1, pos.y, pos.z), color2);\n"
"        imageStore(uOutput, ivec3(pos.x+2, pos.y, pos.z), color3);\n"
"        imageStore(uOutput, ivec3(pos.x+3, pos.y, pos.z), color4);\n"
"    }\n"
"}\n"
;
